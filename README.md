# Лабораторная работа №4

# Генетический алгоритм для решения задачи коммивояжёра

**Выполнил Домницкий Е.А. М4130**

**Цель работы**

Получние навыков разработки эволюционных алгоритмов для решения комбинаторных задач на примере задачи коммивояжёра.

**Оборудование и программное обеспечение**

- Java JDK версии 1.8 и выше
- Watchmaker framework версии 0.7.1 (<https://github.com/dwdyer/watchmaker>)
- Шаблон проекта: <https://gitlab.com/itmo_ec_labs/lab3>

## Представление решений

Объект класса **TspSolution** содержит поле **route** типа **ArrayList**, где хранятся гены в виде перестановок индексов городов. Для реализации генетических операторов предусмотрены вспомогательные методы, через которые обеспечивается взаимодействие с генами. Это необходимо для достижения абстракции и сокрытия. Конструктор **TspSolution(citiesNum)** по умолчанию инициализирует поле **route** случайной перестановкой чисел от 0 до **citiesNum**.

## Мутации

В генетическом алгоритме **TspAlg** используются все виды мутаций сразу.

**TspMutation** - абстрактный родительский класс для мутаций вставкой, перемешиванием, инверсией и перестановкой.

Конструктор мутации принимает на вход число типа double от 0 до 1, представляющее вероятность того, что будет применена данная мутация

- TspScrambleMutation перемешивает гены случайно выбранного участка
- TspInversionMutation инвертирует гены случайно выбранного участка
- TspInsertMutation производит вставку гена, хранящегося по случайно выбранному индексу в позицию после дургого случайно выбранного индекса
- TspSwapMutation меняет местами гены, хранящиеся по двум случайно выбранным индексам

## Кроссовер

**TspCrossover** реализует упорядоченный кроссовер:

- случайным образом выбираются индексы начала a и конца b фрагмента первого родителя
- фрагмент копируется в соответствующий участок дочернего решения, а также заносится в хэш таблицу
- производится циклический обход второго родителя, начиная с позиции b.
- Каждый раз, когда встречается ген, которого нет в хэш таблице, он добавляется в следующую позицию дочернего решения.

## Результаты экспериментов

| Имя проблемы | Размер | Параметры pop. и gen. | Длина маршрута | Количество итераций до сходимости | Оптимальный маршрут |
| --- | --- | --- | --- | --- | --- |
| xqf131 | 131 | 100, 100000 | 1516.74 | 94558 | 564 |
| xqg237 | 237 | 100, 700000 | 2493.76 | 685426 | 1019 |
| bcl380 | 380 | 100, 400000 | 10436 | 335645 | 1681 |
| pbk411 | 411 | 100, 600000 | 7106.34 | 560591 | 1343 |

## Ответы на вопросы

1. Можно ли определить, что полученное решение является глобальным оптимумом?

- В реальных задачах это невозможно.
- За бесконечное время, может, решение и сойдется к глобальному оптимуму с вероятностью, стремящейся к 100%, но в условиях реальных задач число поколений сильно ограничено, а так же в силу вступает дилемма exploration-exploitation.

1. Можно ли допускать невалидные решения (с повторением городов). Если да, то как обрабатывать такие решения и как это повлияет на производительность алгоритма.

Зависит от постановки задачи. Безусловно, если требуется найти именно Гамильтонов цикл – необходимо проверять решения на «гамильтоновость» но это сильно увеличит время выполнения. С другой стороны – в реальных условиях требования «гамильтоновости» не всегда ставится, особенно учитывая, что в графе могут существовать узлы только с 1 ребром, что неизбежно приведет к повторам.

1. Как изменится задача, если убрать условие необходимости возврата в конечную точку?

- Данная задача отличается от исходной, поэтому нужно будет искать новое решение.